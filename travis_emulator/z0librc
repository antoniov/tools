#! /bin/bash
# -*- coding: utf-8 -*-
#
# Copyright (C) SHS-AV s.r.l. (<http://ww.zeroincombenze.it>)
# This software is free software under GNU Affero GPL3
# Bash general purpose library
#__version__=0.1.11


##############################################################################
# Install this lib file in /etc
_install_z0librc () {
    local tgt=/etc/z0librc
    local src=./z0librc
    local xtl=0
    if [ -f $src ]; then
      if [ -f $tgt ]; then
        local xtlver=$(grep "#__version__" $tgt|head -n1|awk -F. '{print $1*10000 + $2*100 + $3}')
        local newver=$(grep "#__version__" $src|head -n1|awk -F. '{print $1*10000 + $2*100 + $3}')
        if [ $newver -gt $xtlver ]; then
          xtl=1
        fi
      else
        xtl=1
      fi
      if [ $xtl -gt 0 ]; then
        if [ "$1" == "-n" ]; then
          echo "cp $src $tgt"
        elif [ $EUID -eq 0 ]; then
          cp $src $tgt
        fi
      fi
    fi
}
export -f _install_z0librc


##############################################################################
# Detect and print more OS informations than uname command
# __version__=0.1.6
# Print Linux OS system information in same way of uname command but returns
# more information. 
# Based on Novell article http://www.novell.com/coolsolutions/feature/11251.html
# Credits:
# - Arun Singh (Novell Senior Software Engineer)
# - antoniomaria.vigliotti@gmail.com (zeroincombenzeÂ® Senior Software Engineer)
# - giuliano69 (https://github.com/Giuliano69/odoo_install/blob/master/odoo8_install.sh)
#
# Check history
#    Date        Author      Result of xname -a -> xname -f
#    2015-08-27  antoniov    Linux CentOS 6.7(Final 2.6.32-504.16.2.el6.x86_64 x86_64) -> RHEL
#    2015-08-27  antoniov    Linux CentOS 7.1.1503(Core 3.10.0-229.1.2.el7.x86_64 x86_64) -> RHEL
#    2015-08-27  antoniov    Linux Ubuntu 12.04( 3.13.0-32-generic i686) -> Debian
#    2015-09-15  antoniov    Linux Ubuntu 14.04( 3.13.0-32-generic i686) -> Debian
#
# Parameter $1:
#   -a  print all
#   -d  print Linux distribution name (empty on Unix)
#   -f  print Linux family (RHEL or Debian, empty on Unix)
#   -k  print Linux kernel release (on Unix same as -r)
#   -m  print machine hardware name
#   -p  print processor architecture
#   -r  print kernel release
#   -v  print distribution version (only on Linux)
xuname () {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
  OS=`uname -s`
  REV=`uname -r`
  MACH=`uname -m`
  KERNEL="$REV"
  VER=""
  DIST=""
  ARCH=`uname -p`
  FAMILY=""
  XDES=""

  if [ "${OS}" = "SunOS" ]; then
    OS=Solaris
    ARCH=`uname -p`
    VER=`uname -v`
    OSSTR="${OS} ${REV}(${ARCH} `uname -v`)"
  elif [ "${OS}" = "AIX" ]; then
    OSSTR="${OS} `oslevel` (`oslevel -r`)"
  elif [ "${OS}" = "Linux" ]; then
    KERNEL=`uname -r`
    CODENAME=""
    if [ -f /etc/vmware-release ]; then
        DIST='VMWare'
        CODENAME=`cat /etc/vmware-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/vmware-release | sed s/.*release\ // | sed s/\ .*//`
    elif [ -f /etc/centos-release ]; then
        DIST='CentOS'
        XDES=$(cat /etc/centos-release|tr -d " \n")
        CODENAME=`cat /etc/centos-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/centos-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/gentoo-release ]; then
        DIST='Gentoo'
        CODENAME=`cat /etc/gentoo-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/gentoo-release | sed s/.*release\ // | sed s/\ .*//`
    elif [ -f /etc/redhat-release ]; then
        DIST='RedHat'
        CODENAME=`cat /etc/redhat-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/SUSE-release ]; then
        DIST="SuSE"
        CODENAME=`cat /etc/SUSE-release | tr "\n" ' '| sed s/VERSION.*//`
        VER=`cat /etc/SUSE-release | tr "\n" ' ' | sed s/.*=\ //`
        FAMILY="RHEL"
    elif [ -f /etc/SuSE-release ]; then
        DIST="SuSE"
        CODENAME=`cat /etc/SuSE-release | tr "\n" ' '| sed s/VERSION.*//`
        VER=`cat /etc/SuSE-release | tr "\n" ' ' | sed s/.*=\ //`
        FAMILY="RHEL"
    elif [ -f /etc/mandriva-release ]; then
        DIST='Mandriva'
        CODENAME=`cat /etc/mandriva-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/mandriva-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/mandrake-release ]; then
        DIST='Mandrake'
        CODENAME=`cat /etc/mandrake-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/mandrake-release | sed s/.*release\ // | sed s/\ .*//`
    elif [ -f /etc/fedora-release ]; then
        DIST="Fedora"
        CODENAME=`cat /etc/fedora-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/fedora-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/slackware-version ]; then
        DIST="Slackware"
        VER=""
    elif [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then
        DIST=$(grep "DISTRIB_ID" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        if [ -z "$DIST" ]; then
           DIST="Ubuntu"
        fi
        VER=$(grep "DISTRIB_RELEASE" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        CODENAME=$(grep "DISTRIB_CODENAME" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        XDES=$(grep "DISTRIB_DESCRIPTION" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        FAMILY="Debian"
    elif [ -f /etc/debian_version ]; then
        DIST="Debian"
        VER=$(lsb_release --release --short)
        FAMILY="Debian"
     elif [ -f /etc/os-release ]; then
        DIST="Debian"
        VER=$(lsb_release --release --short)
        FAMILY="Debian"
    fi
    if [ -f /etc/UnitedLinux-release ]; then
        DIST="${DIST}[`cat /etc/UnitedLinux-release | tr "\n" ' ' | sed s/VERSION.*//`]"
    fi
    OSSTR="${OS} ${DIST} ${VER}(${CODENAME} ${KERNEL} ${MACH})"
  fi
  if [ "$1" == "-c" ]; then
    echo ${CODENAME}
  elif [ "$1" == "-d" ]; then
    echo ${DIST}
  elif [ "$1" == "-f" ]; then
    echo ${FAMILY}
  elif [ "$1" == "-k" ]; then
    echo ${KERNEL}
  elif [ "$1" == "-m" -o  "$1" == "-i" ]; then
    echo ${MACH}
  elif [ "$1" == "-p" ]; then
    echo ${ARCH}
  elif [ "$1" == "-s" ]; then
    echo ${OS}
  elif [ "$1" == "-r" ]; then
    echo ${REV}
  elif [ "$1" == "-v" ]; then
    echo ${VER}
  elif [ "$1" == "-x" ]; then
    echo ${XDES}
  else
    echo ${OSSTR}
  fi 
}
export -f xuname




##############################################################################
# Parse command line arguments in a professional way
# __version__="0.1.8"
# You can define syntax rules declaring some array variables, before calling
# this function. On exit, variable are set on appropriate way.
# Global variables to declare
#   OPTOPTS  array with option switch characters (do not forget h for help)
#      Common option (without -, description and default variable):
#      h help       Show help               opt_help
#      n no         Do nothing (only test)  opt_dry_run
#      V version    Show app version        opt_version
#   OPTDEST  array of destination variables (matches one to one OPTOPTS)
#      Recommend variables:
#      opt_help     show help (int)
#      opt_version  show app version (string)
#      opt_dry_run  do nothing (int)
#   OPTACTI  array of action (matches one to one OPTOPTS)
#      1.st character:
#      0    Set variable to zero (false)
#      1    Set variable to 1 (true)
#      *    Set variable with option switch name itself (i.e. -h)
#      =    Set variable to following option value
#      2.nd character:
#      >    executive command (disable help and version)
#   OPTDEFL  array with defalt values (matches one to one OPTOPTS)
#   OPTMETA  array with meta help to build help (matches one to one OPTOPTS)
#   OPTHELP  array with parameters description to build help (matches one to one OPTOPTS)
#   OPTARGS  array of destination variables of positional arguments (set OPTARGS=() if no args)
#
parseoptargs() {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
    jy=0
    while ((jy<${#OPTDEST[*]})); do
      export ${OPTDEST[jy]}="${OPTDEFL[jy]}"
      ((++jy))
    done
    jy=0
    while ((jy<${#OPTARGS[*]})); do
      export ${OPTARGS[jy]}=""
      ((++jy))
    done
    kk=0
    ii=1
    while ((ii<=$#)); do
      oo="${!ii}"
      if [ "${oo:0:1}" == "-" ]; then
        jj=1
        while ((jj<${#oo})); do
          jy=0
          while ((jy<${#OPTOPTS[*]})); do
            if [ "${oo:jj:1}" == ${OPTOPTS[jy]} ]; then
              # set -x
              a=${OPTACTI[jy]}
              b=${a:1:1}
              if [ "$b" == ">" ]; then
                 export opt_help=0
                 export opt_version=""
              fi
              a=${a:0:1}
              if [ "$a" == "0" -o "$a" == "1" ]; then
                export ${OPTDEST[jy]}=$a
              elif [ "$a" == "*" ]; then
                export ${OPTDEST[jy]}="-${oo:jj:1}"
              elif [ "$a" == "=" ]; then
                ((++jj))
                export ${OPTDEST[jy]}=${oo:jj}
                a="${!OPTDEST[jy]}"
                if [ "$a" ]
                then
                  jj=${#oo}
                else
                  ((++ii))
                  export ${OPTDEST[jy]}="${!ii}"
                fi
              fi
              jy=${#OPTOPTS[*]}
            else
              ((++jy))
            fi
          done
          ((++jj))
          # set +x
        done
      elif [ "$oo" ]; then
        export ${OPTARGS[kk]}="$oo"
        export opt_help=0
        export opt_version=""
        ((++kk))
      fi
      ((++ii))
    done
}
export -f parseoptargs

# Print help for parse command line arguments 
# __version__="0.1.8"
print_help () {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
    txt="Usage: "
    hlp=""
    txt+="$(basename $0) "
      xx="[-"
      jy=0
      while ((jy<${#OPTOPTS[*]})); do
        a=${OPTACTI[jy]}
        a=${a:0:1}
        if [ "$a" == "0" -o "$a" == "1" -o "$a" == "*" ]; then
          if [ "$xx" == "]" ]; then
            xx="][-"
          fi
          txt+="$xx${OPTOPTS[jy]}"
          xx=""
          hlp+=" -${OPTOPTS[jy]}\t\t${OPTHELP[jy]}\n"
        elif [ "$a" == "=" ]; then
          if [ -z "$xx" -o "$xx" == "]" ]; then
            xx="][-"
          fi
          txt+="$xx${OPTOPTS[jy]} ${OPTMETA[jy]}"
          xx="]"
          hlp+=" -${OPTOPTS[jy]} ${OPTMETA[jy]}\t${OPTHELP[jy]}\n"
        fi
        ((++jy))
      done
      if [ -z "$xx" ]; then
        xx="]"
      fi
      txt+="$xx"
      jy=0
      while ((jy<${#OPTARGS[*]})); do
        txt+=" ${OPTARGS[jy]}"
        ((++jy))
      done
      txt+="\n$1\n"
      txt+="$hlp"
      txt+="\n$2"
      echo -e $txt
}
export -f print_help








##############################################################################
# Parse directory to search a file
# __version__="0.1.1"
# Search a file o directory of a list.
# This function is used to find where is an application.
#
# Parameter $1:
#    File/directory to search (if null is searched for directory)
#  Parameter $2:
#    Directory list (space separated) where file could be found (mandatory)
#  Parameter $3:
#    Subdirectory list (space separated) where file could be found (meby be empty)
parsewhich() {
   local p2=
   local p3=
   local result=
   for p2 in $2; do
     if [ -z "$3" ]; then
       if [ -z "$1" ]; then
         if [ -d $p2 ]; then
           result=$(readlink -e $p2)
           break
         fi
       else
         if [ -e $p2/$1 ]; then
           result=$(readlink -e $p2/$1)
           break
         fi
       fi
     else
       for p3 in $3; do
         if [ -z "$1" ]; then
           if [ -d $p2/$p3 ]; then
             result=$(readlink -e $p2/$p3)
             break
           fi
         else
           if [ -e $p2/$p3/$1 ]; then
             result=$(readlink -e $p2/$p3/$1)
             break
           fi
         fi
       done
     fi
   done
   echo "$result"
}