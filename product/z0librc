#! /bin/bash
# -*- coding: utf-8 -*-
#
# Copyright (C) SHS-AV s.r.l. (<http://ww.zeroincombenze.it>)
# This software is free software under GNU Affero GPL3
# Bash general purpose library
#__version__=0.1.28


##############################################################################
# Install this lib file in /etc
_install_z0librc () {
    local tgt=/etc/z0librc
    local src=./z0librc
    local xtl=0
    if [ -f $src ]; then
      if [ -f $tgt ]; then
        if [ "$1" == "-n" ]; then
          local xtlver=$(echo "#__version__=0.1.1"|awk -F\= '{print $2}'|awk -F. '{print $1*10000 + $2*100 + $3}')
        else
          local xtlver=$(grep "#__version__" $tgt|head -n1|awk -F\= '{print $2}'|awk -F. '{print $1*10000 + $2*100 + $3}')
        fi
        local newver=$(grep "#__version__" $src|head -n1|awk -F\= '{print $2}'|awk -F. '{print $1*10000 + $2*100 + $3}')
        if [ $newver -gt $xtlver ]; then
          xtl=1
        fi
      else
        xtl=1
      fi
      if [ $xtl -gt 0 ]; then
        if [ "$1" == "-n" ]; then
          echo "cp $src $tgt"
        elif [ $EUID -eq 0 ]; then
          cp $src $tgt
        fi
      fi
    fi
}
export -f _install_z0librc

##############################################################################
# Set tracelog filename for wlog function
# Log message may be echoed onto console ($3=echo)
# log filename may be /dev/null
#
# Parameter $1:
#    Filename to write (may be full pathname or just basename)
# Parameter $2:
#    "new" means create a new file log, otherwise append to existent file
# Parameter $3:
#    "echo" means wlog echoes message onto console when write log
set_tlog_file () {
    #set -x
    local p=$(dirname "$1")
    local f=$(basename "$1")
    if [ "$p" == "~" ]; then p=$HOME; fi
    if [ "$p" == "." -a "${1:0:2}" != "./" ]; then p=""; fi
    if [ -z "$p" ]; then
      if [ $EUID -eq 0 ]; then
        p=/var/log
      else
        p=$HOME
      fi
    fi
    export FLOG=$(readlink -f $p/$f)
    if [ "$2" == "new" ]; then
      if [ -f "$FLOG" ]; then rm -f "$FLOG"; fi
    fi
    export FLOG_ECHO=${3:-#}
    #set +x
}


##############################################################################
# Write log on file $FLOG: see set_tlog_file function
wlog () {
    dt=$(date +"%F %H:%M:%S")
    if [ -n "$FLOG" ]; then
      echo $dt "$@">$FLOG
    fi
    if [ "$FLOG_ECHO" == "echo" ]; then
      $FLOG_ECHO -e "$@"
    fi
}
export -f wlog


##############################################################################
# Echo meassge and write log on file $FLOG: see set_tlog_file function
elog () {
    wlog "$@"
    if [ "$FLOG_ECHO" != "echo" ]; then
      echo -e "$@"
    fi
}
export -f elog




##############################################################################
# Detect and print more OS informations than uname command
# __version__=0.1.6
# Print Linux OS system information in same way of uname command but returns
# more information.
# Based on Novell article http://www.novell.com/coolsolutions/feature/11251.html
# Credits:
# - Arun Singh (Novell Senior Software Engineer)
# - antoniomaria.vigliotti@gmail.com (zeroincombenzeÂ® Senior Software Engineer)
# - giuliano69 (https://github.com/Giuliano69/odoo_install/blob/master/odoo8_install.sh)
#
# Check history
#    Date        Author      Result of xname -a -> xname -f
#    2015-08-27  antoniov    Linux CentOS 6.7(Final 2.6.32-504.16.2.el6.x86_64 x86_64) -> RHEL
#    2015-08-27  antoniov    Linux CentOS 7.1.1503(Core 3.10.0-229.1.2.el7.x86_64 x86_64) -> RHEL
#    2015-08-27  antoniov    Linux Ubuntu 12.04( 3.13.0-32-generic i686) -> Debian
#    2015-09-15  antoniov    Linux Ubuntu 14.04(trusty 3.13.0-66-generic x86_64) -> Debian
#    2015-10-28  antoniov    Linux VMWare VMware(VMware ESX Server 3 2.4.21-57.ELvmnix i686) -> VMWare
#
# Parameter $1:
#   -a  print all
#   -d  print Linux distribution name (empty on Unix)
#   -f  print Linux family (RHEL or Debian, empty on Unix)
#   -k  print Linux kernel release (on Unix same as -r)
#   -m  print machine hardware name
#   -p  print processor architecture
#   -r  print kernel release
#   -v  print distribution version (only on Linux)
xuname () {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
  OS=`uname -s`
  REV=`uname -r`
  MACH=`uname -m`
  KERNEL="$REV"
  VER=""
  DIST=""
  ARCH=`uname -p`
  FAMILY=""
  XDES=""

  if [ "${OS}" = "SunOS" ]; then
    OS=Solaris
    ARCH=`uname -p`
    VER=`uname -v`
    OSSTR="${OS} ${REV}(${ARCH} `uname -v`)"
  elif [ "${OS}" = "AIX" ]; then
    OSSTR="${OS} `oslevel` (`oslevel -r`)"
  elif [ "${OS}" = "Linux" ]; then
    KERNEL=`uname -r`
    CODENAME=""
    if [ -f /etc/vmware-release ]; then
        DIST='VMWare'
        CODENAME=`cat /etc/vmware-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/vmware-release | sed s/.*release\ // | sed s/\ .*//`
    elif [ -f /etc/centos-release ]; then
        DIST='CentOS'
        XDES=$(cat /etc/centos-release|tr -d " \n")
        CODENAME=`cat /etc/centos-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/centos-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/gentoo-release ]; then
        DIST='Gentoo'
        CODENAME=`cat /etc/gentoo-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/gentoo-release | sed s/.*release\ // | sed s/\ .*//`
    elif [ -f /etc/redhat-release ]; then
        DIST='RedHat'
        CODENAME=`cat /etc/redhat-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/SUSE-release ]; then
        DIST="SuSE"
        CODENAME=`cat /etc/SUSE-release | tr "\n" ' '| sed s/VERSION.*//`
        VER=`cat /etc/SUSE-release | tr "\n" ' ' | sed s/.*=\ //`
        FAMILY="RHEL"
    elif [ -f /etc/SuSE-release ]; then
        DIST="SuSE"
        CODENAME=`cat /etc/SuSE-release | tr "\n" ' '| sed s/VERSION.*//`
        VER=`cat /etc/SuSE-release | tr "\n" ' ' | sed s/.*=\ //`
        FAMILY="RHEL"
    elif [ -f /etc/mandriva-release ]; then
        DIST='Mandriva'
        CODENAME=`cat /etc/mandriva-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/mandriva-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/mandrake-release ]; then
        DIST='Mandrake'
        CODENAME=`cat /etc/mandrake-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/mandrake-release | sed s/.*release\ // | sed s/\ .*//`
    elif [ -f /etc/fedora-release ]; then
        DIST="Fedora"
        CODENAME=`cat /etc/fedora-release | sed s/.*\(// | sed s/\)//`
        VER=`cat /etc/fedora-release | sed s/.*release\ // | sed s/\ .*//`
        FAMILY="RHEL"
    elif [ -f /etc/slackware-version ]; then
        DIST="Slackware"
        VER=""
    elif [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then
        DIST=$(grep "DISTRIB_ID" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        if [ -z "$DIST" ]; then
           DIST="Ubuntu"
        fi
        VER=$(grep "DISTRIB_RELEASE" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        CODENAME=$(grep "DISTRIB_CODENAME" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        XDES=$(grep "DISTRIB_DESCRIPTION" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
        FAMILY="Debian"
    elif [ -f /etc/debian_version ]; then
        DIST="Debian"
        VER=$(lsb_release --release --short)
        FAMILY="Debian"
     elif [ -f /etc/os-release ]; then
        DIST="Debian"
        VER=$(lsb_release --release --short)
        FAMILY="Debian"
    fi
    if [ -f /etc/UnitedLinux-release ]; then
        DIST="${DIST}[`cat /etc/UnitedLinux-release | tr "\n" ' ' | sed s/VERSION.*//`]"
    fi
    OSSTR="${OS} ${DIST} ${VER}(${CODENAME} ${KERNEL} ${MACH})"
  fi
  if [ "$1" == "-c" ]; then
    echo ${CODENAME}
  elif [ "$1" == "-d" ]; then
    echo ${DIST}
  elif [ "$1" == "-f" ]; then
    echo ${FAMILY}
  elif [ "$1" == "-k" ]; then
    echo ${KERNEL}
  elif [ "$1" == "-m" -o  "$1" == "-i" ]; then
    echo ${MACH}
  elif [ "$1" == "-p" ]; then
    echo ${ARCH}
  elif [ "$1" == "-s" ]; then
    echo ${OS}
  elif [ "$1" == "-r" ]; then
    echo ${REV}
  elif [ "$1" == "-v" ]; then
    echo ${VER}
  elif [ "$1" == "-x" ]; then
    echo ${XDES}
  else
    echo ${OSSTR}
  fi
}
export -f xuname




##############################################################################
# Parse command line arguments in a professional way
# __version__="0.1.8"
# You can define syntax rules declaring some array variables, before calling
# this function. On exit, variable are set on appropriate way.
# Global variables to declare
#   OPTOPTS  array with option switch characters (do not forget h for help)
#      Common option (without -, description and default variable):
#      h help       Show help               opt_help
#      n no         Do nothing (only test)  opt_dry_run
#      V version    Show app version        opt_version
#   OPTDEST  array of destination variables (matches one to one OPTOPTS)
#      Recommend variables:
#      opt_help     show help (int)
#      opt_version  show app version (string)
#      opt_dry_run  do nothing (int)
#   OPTACTI  array of action (matches one to one OPTOPTS)
#      1.st character:
#      0    Set variable to zero (false)
#      1    Set variable to 1 (true)
#      *    Set variable with option switch name itself (i.e. -h)
#      =    Set variable to following option value
#      2.nd character:
#      >    executive command (disable help and version)
#   OPTDEFL  array with defalt values (matches one to one OPTOPTS)
#   OPTMETA  array with meta help to build help (matches one to one OPTOPTS)
#   OPTHELP  array with parameters description to build help (matches one to one OPTOPTS)
#   OPTARGS  array of destination variables of positional arguments (set OPTARGS=() if no args)
#
parseoptargs() {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
    jy=0
    while ((jy<${#OPTDEST[*]})); do
      export ${OPTDEST[jy]}="${OPTDEFL[jy]}"
      ((++jy))
    done
    jy=0
    while ((jy<${#OPTARGS[*]})); do
      export ${OPTARGS[jy]}=""
      ((++jy))
    done
    kk=0
    ii=1
    while ((ii<=$#)); do
      oo="${!ii}"
      if [ "${oo:0:1}" == "-" ]; then
        jj=1
        while ((jj<${#oo})); do
          jy=0
          while ((jy<${#OPTOPTS[*]})); do
            if [ "${oo:jj:1}" == ${OPTOPTS[jy]} ]; then
              # set -x
              a=${OPTACTI[jy]}
              b=${a:1:1}
              if [ "$b" == ">" ]; then
                 export opt_help=0
                 export opt_version=""
              fi
              a=${a:0:1}
              if [ "$a" == "0" -o "$a" == "1" ]; then
                export ${OPTDEST[jy]}=$a
              elif [ "$a" == "*" ]; then
                export ${OPTDEST[jy]}="-${oo:jj:1}"
              elif [ "$a" == "=" ]; then
                ((++jj))
                export ${OPTDEST[jy]}=${oo:jj}
                a="${!OPTDEST[jy]}"
                if [ "$a" ]
                then
                  jj=${#oo}
                else
                  ((++ii))
                  export ${OPTDEST[jy]}="${!ii}"
                fi
              fi
              jy=${#OPTOPTS[*]}
            else
              ((++jy))
            fi
          done
          ((++jj))
          # set +x
        done
      elif [ "$oo" ]; then
        export ${OPTARGS[kk]}="$oo"
        export opt_help=0
        export opt_version=""
        ((++kk))
      fi
      ((++ii))
    done
}
export -f parseoptargs


# Print help for parse command line arguments
# __version__="0.1.8"
print_help () {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
    txt="Usage: "
    hlp=""
    txt+="$(basename $0) "
      xx="[-"
      jy=0
      while ((jy<${#OPTOPTS[*]})); do
        a=${OPTACTI[jy]}
        a=${a:0:1}
        if [ "$a" == "0" -o "$a" == "1" -o "$a" == "*" ]; then
          if [ "$xx" == "]" ]; then
            xx="][-"
          fi
          txt+="$xx${OPTOPTS[jy]}"
          xx=""
          hlp+=" -${OPTOPTS[jy]}\t\t${OPTHELP[jy]}\n"
        elif [ "$a" == "=" ]; then
          if [ -z "$xx" -o "$xx" == "]" ]; then
            xx="][-"
          fi
          txt+="$xx${OPTOPTS[jy]} ${OPTMETA[jy]}"
          xx="]"
          hlp+=" -${OPTOPTS[jy]} ${OPTMETA[jy]}\t${OPTHELP[jy]}\n"
        fi
        ((++jy))
      done
      if [ -z "$xx" ]; then
        xx="]"
      fi
      txt+="$xx"
      jy=0
      while ((jy<${#OPTARGS[*]})); do
        txt+=" ${OPTARGS[jy]}"
        ((++jy))
      done
      txt+="\n$1\n"
      txt+="$hlp"
      txt+="\n$2"
      echo -e $txt
}
export -f print_help




##############################################################################
# Parse directory to search a file
# __version__="0.1.1"
# Search a file o directory of a list.
# This function is used to find where is an application.
#
# Parameter $1:
#    File to search (if null is searched just for directory of $2 ...)
# Parameter $2:
#    Directory list (space separated) where file could be found (mandatory)
# Parameter $3:
#    Level 2 subdirectory list (space separated) where file could be found (mayby be empty)
# Parameter $4:
#    Level 3 subdirectory list (space separated) where file could be found (mayby be empty)
# Parameter $5:
#    Level 4 subdirectory list (space separated) where file could be found (mayby be empty)
# Parameter $6:
#    Level 5 subdirectory list (space separated) where file could be found (mayby be empty)
findpkg() {
   local p2=
   local p3=
   local p4=
   local p5=
   local p6=
   local r2=
   local r3=
   local r4=
   local r5=
   local r6=
   local result=
   for p2 in $2; do
     r2=$p2
     for p3 in $3 .; do
       if [ "$p3" == "." ]; then r3=; else r3=/$p3; fi
       for p4 in $4 .; do
         if [ "$p4" == "." ]; then r4=; else r4=/$p4; fi
         for p5 in $5 .; do
           if [ "$p5" == "." ]; then r5=; else r5=/$p5; fi
           for p6 in $6 .; do
             if [ "$p6" == "." ]; then r6=; else r6=/$p6; fi
             if [ -z "$1" ]; then
               if [ -d $r2$r3$r4$r5$r6 ]; then
                 result=$(readlink -e $r2$r3$r4$r5$r6)
                 break
               fi
             else
               if [ -e $r2$r3$r4$r5$r6/$1 ]; then
                 result=$(readlink -e $r2$r3$r4$r5$r6/$1)
                 break
               fi
             fi
           done
           if [ -n "$result" ]; then break; fi
         done
         if [ -n "$result" ]; then break; fi
       done
       if [ -n "$result" ]; then break; fi
     done
     if [ -n "$result" ]; then break; fi
   done
   echo "$result"
}
export -f findpkg




##############################################################################
# Create empty dictionary (based on associative array)
# Must be called twice, before as 'a_new', then as 'a_active'
# __version__="0.1.5"
# Return:
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Id of table for access
a_new () {
    cmd="unset DEFDICT$1 DEFRULE$1"
    echo "$cmd"
}
export -f a_new
a_active () {
    if [ "$XU_FH" != "RHEL" -a "$XU_FH" != "Debian" ]; then
      XU_FH=$(xuname "-f")
      local x=$(xuname "-v")
      XU_DISTO=$(xuname "-d")${x:0:1}
    elif [ -z "$XU_DISTO" ]; then
      local x=$(xuname "-v")
      XU_DISTO=$(xuname "-d")${x:0:1}
    fi
    FH="$XU_FH"
    DISTO="$XU_DISTO"
    cmd="declare -A DEFDICT$1 DEFRULE$1"
    echo "$cmd"
}
export -f a_active


##############################################################################
# Add key and value to dictionary (associative array)
# key may be regex to match multiple values
# It's a ugly solution but currently works
# __version__="0.1.5"
# Global variables declared by a_active
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Id of table (may be 0..3)
# Parameter $2:
#    Dictionary key; if begin with "^" is a regex, otherwise is unique key
# Parameter $3:
#    Dictionary value
# Parameter $4:
#    "-d"   key is specific of Linux distribution
#    "-f"   key is specific of Linux family
# Parameter $5:
#    "-D"   key is specific for development environment
a_add () {
    if [ "$2" ]; then
      if [ "$4" == "-d" ]; then
        local SFX="__$XU_DISTO"
      elif [ "$4" == "-f" ]; then
        local SFX="__$XU_FH"
      else
        local SFX=
      fi
      if [ "$5" == "-D" ]; then
        local SFX="${SFX}__DEV"
      fi
      if [ "$1" == "0" ]; then
        if [ "${2:0:1}" == "^" ]; then
          DEFRULE0[$2$SFX]="$3"
        else
          DEFDICT0[$2$SFX]="$3"
        fi
      elif [ "$1" == "1" ]; then
        if [ "${2:0:1}" == "^" ]; then
          DEFRULE1[$2$SFX]="$3"
        else
          DEFDICT1[$2$SFX]="$3"
        fi
      elif [ "$1" == "2" ]; then
        if [ "${2:0:1}" == "^" ]; then
          DEFRULE2[$2$SFX]="$3"
        else
          DEFDICT2[$2$SFX]="$3"
        fi
      elif [ "$1" == "3" ]; then
        if [ "${2:0:1}" == "^" ]; then
          DEFRULE3[$2$SFX]="$3"
        else
          DEFDICT3[$2$SFX]="$3"
        fi
      fi
    fi
}
export -f a_add


##############################################################################
# Find value in associative array
# It's a ugly solution but currently works
# __version__="0.1.5"
# Global variables create by a_append
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Id of table
# Parameter $2:
#    Dictionary key to search
# Parameter $3:
#    Dictionary value
# Return:
#    dictionary value to stdout
#    status
a_find () {
    local p=""
    local sts=1
    local x
    if [ "$2" ]; then
      local SFX=
      if [ "$1" == "0" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          p=${DEFDICT0[$2$SFX]}
          if [ "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE0[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE0[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "$2__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE0[$K]}
                  local sts=0
                  break
                elif [[ "$2__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE0[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq 0 ]; then break; fi
          done
        fi
      elif [ "$1" == "1" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          p=${DEFDICT1[$2$SFX]}
          if [ "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE1[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE1[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "$2__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE1[$K]}
                  local sts=0
                  break
                elif [[ "$2__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE1[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq 0 ]; then break; fi
          done
        fi
      elif [ "$1" == "2" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          p=${DEFDICT2[$2$SFX]}
          if [ "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE2[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE2[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "$2__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE2[$K]}
                  local sts=0
                  break
                elif [[ "$2__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE2[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq 0 ]; then break; fi
          done
        fi
      elif [ "$1" == "3" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          p=${DEFDICT3[$2$SFX]}
          if [ "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE3[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE3[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "$2__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE3[$K]}
                  local sts=0
                  break
                elif [[ "$2__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE3[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq 0 ]; then break; fi
          done
        fi
      fi
      if [ "$p" ]; then
        local sts=0
      fi
    fi
    echo "$p"
    return $sts
}
export -f a_find


##############################################################################
# get value from config file
# if file does not exist, or parameter does not exist, return default value
# __version__="0.1.1"
# Require a_find
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Config file name
# Parameter $2:
#    Paramater key to search
# Return:
#    parameter value
get_cfg_value () {
    local p
    if [ -z $2 ]; then
      p=
      echo $p
      return
    # elif [ "$CONFN" -a -f $CONFN ]; then
    #   p=$(grep "^$2 *=.*" $CONFN 2>/dev/null|awk -F\= '{print $2}')
    #   p=$(echo $p|tr -d "\"'")
    else
      p=
    fi
    if [ -z "$p" -o "$p" == "False" ]; then
      p=$(a_find "0" "$2")
    fi
    if [ "$p" == "None" ]; then
      p=
    fi
    echo "$p"
}
export -f get_cfg_value

init_cfg () {
    echo $(a_new "0")
    $(a_active "0")
}
export -f init_cfg


active_cfg () {
    echo $(a_active "0")
}
export -f active_cfg

set_cfg_def () {
    a_add "0" "$1" "$2"
}
export -f set_cfg_def


link_cfg () {
    if [ "$1" ]; then
      a_add "0" "CONFN" "$1"
      CONFN="$1"
      if [ -z "$2" ]; then
        local cfndef="$1.sample"
      else
        local cfndef="$2"
      fi
      if [ -f "$cfndef" ]; then
        a_add "0" "CONFND" "$1"
        local key
        local val
        while IFS=\= read -r kk val; do
          kk=$(echo $kk|tr -d "\"' ")
          val=$(echo $val|tr -d "\"'")
          if [ "${kk:0:1}" != "#" ]; then
            a_add "0" "$kk" "$val"
            if [ "$kk" == "CONFN" ]; then
              CONFN="$val"
            fi
          fi
        done < "$cfndef"
      fi
      if [ -f "$CONFN" ]; then
        local key
        local val
        while IFS=\= read -r kk val; do
          kk=$(echo $kk|tr -d "\"' ")
          val=$(echo $val|tr -d "\"'")
          if [ "${kk:0:1}" != "#" ]; then
            a_add "0" "$kk" "$val"
          fi
        done < "$CONFN"
      fi
    fi
}
export -f link_cfg
