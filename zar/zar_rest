#! /bin/bash
# -*- coding: utf-8 -*-
# Duplicate postgres DB
#
# author: Antonio M. Vigliotti - antoniomaria.vigliotti@gmail.com
# (C) 2015-2016 by SHS-AV s.r.l. - http://www.shs-av.com - info@shs-av.com
# This free software is released under GNU Affero GPL3

THIS=$(basename $0)
TDIR=$(readlink -f $(dirname $0))
for x in "$TDIR" "$TDIR/.." "." ".." "~" "/etc"; do
  if [ -e $x/z0librc ]; then
    . $x/z0librc
    Z0LIBDIR=$x
    Z0LIBDIR=$(readlink -e $Z0LIBDIR)
    break
  fi
done
if [ -z "$Z0LIBDIR" ]; then
  echo "Library file z0librc not found!"
  exit 2
fi
TESTDIR=$(findpkg "" "$TDIR . .." "tests")
RUNDIR=$(readlink -e $TESTDIR/..)

__version__="1.3.20"


detached_login() {
# detached_login([path] [path2] [path3])
    if [ $opt_cron -gt 0 -a "$SHELL" == "/bin/sh" ]; then
      if [ $opt_dry_run -eq 0 ]; then
        fqcmd=$(readlink -f $0)
        wlog "Run $fqcmd in cron mode"
        SHELL=/bin/bash exec "$fqcmd" "$@"
      fi
    elif [ $opt_cron -gt 0 -a -f $HOME/.bash_profile ]; then
      wlog "Simulate login ($HOME/.bash_profile)"
      . $HOME/.bash_profile
    fi
    if [[ ":$PATH:" =~ /usr/local/bin ]]; then
      :
    else
      export PATH=/usr/local/bin:$PATH
    fi
    if [ -n "$1" ]; then
      if [ -d $1 ]; then
        if [[ ":$PATH:" =~ $1 ]]; then
          :
        else
          export PATH=$PATH:$1
        fi
      fi
    fi
    if [ -n "$2" ]; then
      if [ -d $2 ]; then
        if [[ ":$PATH:" =~ $2 ]]; then
          :
        else
          export PATH=$PATH:$2
        fi
      fi
    fi
    if [ -n "$3" ]; then
      if [ -d $3 ]; then
        if [[ ":$PATH:" =~ $3 ]]; then
          :
        else
          export PATH=$PATH:$3
        fi
      fi
    fi
    wlog "PATH=$PATH"
}


kill_process() {
    sql="select datname,pid,xact_start,waiting,state from pg_stat_activity where datname='$NEWDB' and pid<>pg_backend_pid();"
    flog=$HOME/dup4test_proc.log
    psql -U$opt_user -d postgres -tc "$sql" -o $flog
    while IFS=\| read db pid pdt w st; do
      if [ -n "$st" ]; then
        db=$(echo $db)
        w=$(echo $w)
        st=$(echo $st)
        pid=$(echo $pid)
        if [ "$db" == "$NEWDB" ]; then
          if [ "$w" != "f" -a "${st:0:4}" != "idle" ]; then
            echo "DB non deletable"
          else
            echo "killing process $pid"
            kill $pid
          fi
        fi
      fi
    done < $flog
    rm -f $flog
}

backup_db() {
    local db=$1
    if [ $opt_dry_run -gt 0 ]; then
      wlog "> pg_dump -U$opt_user -Fp -f $DBCKDIR/$db-00000000.sql $db"
    else
      kill_process
      wlog "\$ pg_dump -U$opt_user -Fp -f $DBCKDIR/$db-00000000.sql $db"
      pg_dump -U$opt_user -Fp -f $DBCKDIR/$db-00000000.sql $db
    fi
}

check_4_table() {
# check_4_table DB table what
    local DB=$1
    local tbl=$2
    local what=$3
    local x
    if [ "$what" == "exists" ]; then
       x=$(psql -tc "select * from pg_tables where tablename = '$tbl';" $DB)
    elif [ "$what" == "with_data" ]; then
       x=$(psql -tc "select * from $tbl;" $DB)
    elif [ "$what" == "active_data" ]; then
       x=$(psql -tc "select * from $tbl where active=true;" $DB)
    elif [ "$what" == "reset_data" ]; then
       x=$(psql -tc "select * from $tbl where active=true;" $DB)
    else
       x=""
    fi
    if [ -n "$x" ]; then
      if [ "$what" == "reset_data" ]; then
         psql -tc "update $tbl set active=false where active=true;" $DB
      fi
      return 0
    fi
    return 1
}

stop_services() {
# stop_services(DB quickmode)
    if [ -z "$1" ]; then
      return 1
    fi
    local x DB tbl res wtm act wfid SVCS SVCS2
    DB=$1
    SVCS="$(get_cfg_value 0 services_2_stop)"
    if [ -z "$SVCS" ]; then
      SVCS="ir_mail_server fetchmail_server base_action_rule ir_cron"
    else
      SVCS=${SVCS//,/ }
    fi
    SVCS2="$(get_cfg_value 0 services_2_restart)"
    if [ -z "$SVCS2" ]; then
      SVCS2="ir_mail_server base_action_rule"
    else
      SVCS2=${SVCS2//,/ }
    fi
    declare -A tblok tblwf
    if [ -z "${svc2run[*]}" ]; then
      unset svc2run
      declare -gA svc2run
    fi
    wrkflw=("exists" "with_data" "reset_data" "Ok")
    if [ -n "$2" ]; then
      wlog ". Starting services quick checker on $DB"
      local MAXC=5
    else
       wlog ".. Starting services checker on $DB ..."
      local MAXC=50
    fi
    res=1
    while [ $res -ne 0 -a $MAXC -gt 0 ]; do
      res=0
      wtm=2
      for tbl in $SVCS; do
        if [ -z "${tblwf[$tbl]}" ]; then
          wfid=0
        else
          wfid=${tblwf[$tbl]}
        fi
        act=${wrkflw[$wfid]}
        if [ "$act" != "Ok" ]; then
          res=1
          check_4_table $DB $tbl $act
          if [ $? -eq 0 ]; then
            wlog ".. Table $tbl $act ok"
            ((wfid++))
            tblwf[$tbl]=$wfid
             if [ "$act" == "with_data" -a -z "${svc2run[$tbl]}" ]; then
               x=$(psql -tc "select id from $tbl where active=true;" $DB|tr "\n" " ")
               if [ -n "$x" ]; then
                 svc2run[$tbl]="${svc2run[$tbl]} $x"
                 svc2run[$tbl]="$(echo ${svc2run[$tbl]})"
               fi
             fi
          else
            if [ "${tblok[$tbl]}" != "$act" ]; then
              wlog ".. Table $tbl, action $act failed !!"
              tblok[$tbl]="$act"
              if [ "$act" == "exists" -a $MAXC -lt 75 ]; then
                let MAXC="$MAXC+5"
              fi
            fi
            ((wtm++))
          fi
        fi
      done
      if [ $res -ne 0 ]; then
        sleep $wtm
      fi
      ((MAXC--))
    done
    for tbl in $SVCS; do
      if [ -n "$2" -a -n "${svc2run[$tbl]}" ]; then
        if [[ " $SVCS2 " =~ [[:space:]]$tbl[[:space:]] ]]; then
          wlog ".. update $tbl set active=true where id in (${svc2run[$tbl]});"
          psql -tc "update $tbl set active=true where id in (${svc2run[$tbl]});" $DB
        fi
      fi
    done
    return 0
}


OPTOPTS=(h        K        l       m        n            o        R       U          V           v)
OPTDEST=(opt_help opt_cron opt_log opt_mail opt_dry_run  opt_name opt_rst opt_user   opt_version opt_verbose)
OPTACTI=(1        1        "="     1        1            "="      1       "="        "*>"        1)
OPTDEFL=(0        0        ""      -1       0            ""       0       "postgres" ""          0)
OPTMETA=("help"   "cron"   "file" "mail"    "do nothing" "fname"  ""      "username" "version"   "verbose")
OPTHELP=("this help"\
 "run in cron environment"\
 "log filename (def /var/log/zar/restdb.log)"\
 "disable mail server on target DB"\
 "do nothing (dry-run)"\
 "input filename (def dbname-date)"\
 "stop mail server and services"\
 "username (def postgres)"\
 "show version"\
 "verbose mode")
OPTARGS=(olddb newdb seldate)

parseoptargs $@

if [ "$opt_version" ]
then
  echo "$__version__"
  exit 0
fi
if [ $opt_help -gt 0 ]
then
  print_help "Restore/duplicate postgres DB"\
  "(C) 2015-2016 by zeroincombenze(R)\nhttp://wiki.zeroincombenze.org/en/Linux/dev\nAuthor: antoniomaria.vigliotti@gmail.com"
  exit 0
fi
if [ -z "$opt_log" ]; then
  publog="/var/log/zar/restdb.log"
else
  publog=$opt_log
fi
FCONF=$TDIR/zar.conf
CFG_init
set_tlog_file "$publog"
if [ $opt_cron -gt 0 ]; then
  detached_login "$@"
fi
link_cfg $FCONF
if [ $opt_rst -gt 0 ]; then
  stop_services "$olddb"
  exit $?
fi
wlog "Starting restore/duplicate $__version__ by $USER"

DBCKDIR=$(findpkg "" "/var/lib" "postgresql  pgsql" "8.2 8.3 9.0 9.1 9.2 9.3 9.4" "backups")
if [ -z "$DBCKDIR" ]; then
  wlog "No postgres backup directory found!"
  exit 1
fi
wlog "Found $DBCKDIR directory"
HOST_PRD=$(get_cfg_value 0 production_host)
HOST_DEV=$(get_cfg_value 0 development_host)
wlog "PRD=$HOST_PRD"
wlog "DEV=$HOST_DEV"
OWN=$(get_cfg_value 0 db_user)
if [ -z "$OWN" ]; then
  OWN=odoo
fi
wlog "OWN=$OWN"
if [ -n "$opt_name" ]; then
   if [ -z "$olddb" ]; then
     echo "Missing DB name, when restore from file!"
     exit 1
   elif [ -z "$newdb" ]; then
     newdb=$olddb
   fi
fi
if [ -z "$olddb" ]; then
  OLDDB=$(get_cfg_value 0 db_name)
else
  OLDDB=$olddb
fi
if [ -z "$newdb" ]; then
  NEWDBS=$(get_cfg_value 0 bck_db)
  if [ "$NEWDBS" == "*" ]; then
    NEWDBS=$OLDDB
  fi
elif [ "$newdb" == "*" ]; then
  NEWDBS=$OLDDB
else
  NEWDBS=$newdb
fi
if [ -z "$OLDDB" -o -z "$NEWDBS" ]; then
  print_help
  exit
fi
TEST_DB="$(get_cfg_value 0 test_db)"
if [ -z "$TEST_DB" ]; then
  TEST_DB="$(get_cfg_value 0 bck_db)"
fi
wlog "TEST_DB=$TEST_DB"
if [[ $seldate =~ [0-9]{8} ]]; then
  NDAYSB=$seldate
elif [ "$HOSTNAME" == "$HOST_PRD" ]; then
  NDAYSB="$(get_cfg_value 0 PRD_num_days_before)"
elif [ "$HOSTNAME" == "$HOST_DEV" ]; then
  NDAYSB="$(get_cfg_value 0 DEV_num_days_before)"
fi
if [ -z "$NDAYSB" ]; then
  NDAYSB="$(get_cfg_value 0 num_days_before)"
fi
if [ -z "$NDAYSB" ]; then
  NDAYSB=yesterday
fi
ODOO_RPC_HOST="$(get_cfg_value 0 odoo_rpc_host)"
if [ -z "$ODOO_RPC_HOST" ]; then ODOO_RPC_HOST=localhost; fi
ODOO_RPC_PROTOCOL="$(get_cfg_value 0 odoo_rpc_protocol)"
if [ -z "$ODOO_RPC_PROTOCOL" ]; then ODOO_RPC_PROTOCOL=xmlrpc; fi
ODOO_RPC_XMLPORT="$(get_cfg_value 0 odoo_rpc_xmlport)"
if [ -z "$ODOO_RPC_XMLPORT" ]; then ODOO_RPC_XMLPORT=8069; fi
ODOO_VERSION="$(get_cfg_value 0 odoo_version)"
if [ -z "$ODOO_VERSION" ]; then ODOO_VERSION=7.0; fi
ODOO_RPC_PWD="$(get_cfg_value 0 odoo_rpc_pwd)"
if [ -z "$ODOO_RPC_PWD" ]; then ODOO_RPC_PWD=admin; fi
ctr=0
passed=""
for NEWDB in ${NEWDBS//,/ }; do
  for ND in ${NDAYSB//,/ }; do
    if [[ " $passed " =~ [[:space:]]$NEWDB[[:space:]] ]]; then
       continue
    fi
    if [ -z "$opt_name" ]; then
      if [[ $ND =~ [0-9]{8} ]]; then
        dtdb=$ND
      elif [[ $ND =~ [0-9]+ ]]; then
        NDAYB=-${ND}day
        dtdb=$(date -d $NDAYB +"%Y%m%d")
      else
        dtdb=$(date -d yesterday +"%Y%m%d")
      fi
      if [[ " $passed " =~ [[:space:]]$dtdb[[:space:]] ]]; then
         continue
      fi
    else
      dtdb="00000000"
    fi
    if [ $opt_mail -eq -1 ]; then
      opt_mail=0
      if [ "$HOSTNAME" == "$HOST_DEV" ]; then
        opt_mail=1
        wlog "Restored DB is for test because Development Host"
      elif [[ $NEWDB =~ $TEST_DB ]]; then
        opt_mail=1
        wlog "Restored DB is for test as classificated"
      fi
    fi
    if [ -z "$opt_name" ]; then
      sqlfname=$DBCKDIR/$OLDDB-$dtdb.sql
    else
      sqlfname=$opt_name
    fi
    echo "Searching $sqlfname"
    if [ ! -f $sqlfname ]; then
      echo "No sql file found!!!"
      exit 1
    fi
    if [ $opt_dry_run -eq 0 ]; then
      wlog "Restore/duplicate $sqlfname $NEWDB"
    else
      echo "Should restore $sqlfname $NEWDB"
    fi
    if [ "$NEWDB" == "$OLDDB" -a "$dtdb" != "00000000" ]; then
      backup_db $OLDDB
    fi
    pycmd=$HOME/$NEWDB.py
    echo "import oerplib">$pycmd
    echo "oerp = oerplib.OERP(server='$ODOO_RPC_HOST',">>$pycmd
    echo "                    protocol='$ODOO_RPC_PROTOCOL',">>$pycmd
    echo "                    port='$ODOO_RPC_XMLPORT',">>$pycmd
    echo "                    version='$ODOO_VERSION')">>$pycmd
    echo "oerp.db.drop('$ODOO_RPC_PWD',">>$pycmd
    echo "             '$NEWDB')">>$pycmd
    fsql=$HOME/$NEWDB.sql
    wlog "Prepare file script $fsql ..."
    echo "\\c postgres">$fsql
    echo "\\echo Creating new DB $NEWDB">>$fsql
    echo "DROP DATABASE IF EXISTS $NEWDB;">>$fsql
    echo "CREATE DATABASE $NEWDB TEMPLATE template1;">>$fsql
    echo "\\c $NEWDB">>$fsql
    echo "\\echo Loading data into DB $NEWDB">>$fsql
    echo "\\i $sqlfname">>$fsql
    echo "ALTER DATABASE $NEWDB OWNER TO $OWN;">>$fsql
    if [ $opt_dry_run -eq 0 ]; then
      wlog "Starting restore $NEWDB"
      kill_process
      python $pycmd
      if [ $opt_mail -gt 0 ]; then
        $0 -R "$NEWDB" &
      fi
      psql -U$opt_user -d postgres -f $fsql -o $NEWDB.log
      stop_services "$NEWDB" "quick"
      rm -f $pycmd
      wlog "Restore $NEWDB terminated"
      ((ctr++))
      if [ -n "$opt_name" ]; then
        break
      fi
    fi
    passed="$passed $NEWDB $dtdb"
  done
  if [ -n "$opt_name" ]; then
    break
  fi
done
if [ $opt_dry_run -eq 0 ]; then
  sleep 30
fi
wlog "All $ctr databases are restored"
exit 0
